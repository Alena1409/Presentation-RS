<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h1>RxJS</h1>
				<p>Alekseeva Alena 2024Q4</p>
			</section>

			<section>
				<section>
					<h2>Introduction to RxJS</h2>
					<ul>
						<li>RxJS is a library that brings Reactive Extensions to JavaScript. It also has versions for
							other languages, like RxJava, RxSwift, and RxPy.</li>
						<li>RxJS provides a framework that helps interfaces automatically respond to events and data
							changes.</li>
					</ul>
				</section>
				<section>
					<h3>Main Advantages</h3>
					<ul>
						<li>It uses declarative code, making programs easier to read and understand.</li>
						<li>It supports cancelable operations, which helps manage resources better.</li>
						<li>It provides excellent tools for handling errors gracefully.</li>
					</ul>
				</section>

				<section>
					<h3>Main Purpose</h3>
					<p>RxJS makes it comfortable to manage asynchronous operations and events using a reactive
						programming style.</p>
				</section>
			</section>

			<section>
				<section>
					<h2>Main concept</h2>
					<h3>everything is a stream</h3>
					<p>To understand RxJS, you need to think in terms of streams rather than traditional JavaScript
						operations</p>
				</section>
				<section>
					<ul>
						<li>Each value in a stream goes through all operations one by one</li>
						<li>It’s different from arrays, which process one step at a time.</li>
					</ul>
					<pre>Here is an example with arrays and RxJS:<code>
 [1,2,3,4,5].map(v => v * 2).filter(v => v> 6)
 // Processes all elements through map, then all through filter
											</code></pre>
					<pre><code>
 from([1,2,3,4,5])
 	.pipe(
 		map(v => v * 2),
 		filter(v => v> 6)
 	)
 	.subscribe(result) 
 // Each item flows through the entire pipeline individually
											</code></pre>

				</section>
			</section>

			<section>
				<section>
					<h3>Versatility of RxJS Streams</h3>
					<li>Stream can be from arrays, events, or Promises.</li>
					<li>You use the .pipe() method to work with the data.</li>
					<li>It is like a pipeline — each step transforms the data.</li>
				</section>
				<section>
					<h3>Ways to Create Streams in RxJS</h3>
					<ul>
						<li>
							<p>from() — creates a stream from an array, string, Promise, or iterable object</p>
							<pre><code>
	from([1, 2, 3, 4, 5])
		.pipe(/* operators */)
		.subscribe(value => console.log(value));
	</code></pre>
						</li>
						<li>
							<p>of() — creates a stream from individual values</p>
							<pre><code>
	of(1, 2, 3, 'string', {obj: 'value'})
		.subscribe(value => console.log(value));
								</code></pre>
						</li>
					</ul>
				</section>
				<section>
					<ul>
						<li>
							<p>fromEvent() — creates a stream from DOM events</p>
							<pre><code>fromEvent(document, 'click').subscribe(e => console.log(e));</code></pre>
						</li>
						<li>
							<p>interval() — creates a timer that counts numbers</p>
							<pre><code>interval(1000).subscribe(count => console.log(count));</code></pre>
						</li>
						<li>
							<p>timer() — creates a stream with a delay and optional interval</p>
							<pre><code>timer(3000, 1000).subscribe(value => console.log(value));</code></pre>
						</li>
						<li>...</li>
					</ul>
				</section>
				<section>
					<h3>Creating streams in Angular</h3>
					<ul>
						<li><code>formControl.valueChanges</code></li>
						<li><code>this.http.get(...)</code></li>
						<li><code>this.route.params</code>, <code>this.router.events</code></li>

					</ul>
				</section>
			</section>
			<section>
				<p>new Observable() — creating a stream manually with full control over its behavior</p>
				<pre><code class="language-ts">const observable = new Observable(subscriber => {
				  subscriber.next(1);
				  subscriber.error(err);
				  subscriber.complete();
				});
				//Observable = source of data</code></pre>
				<pre><code class="language-ts">const observer = {
				  next: val => console.log('Value:', val),
				  error: err => console.error('Error:', err),
				  complete: () => console.log('Done')
				};
				//Observer = data handler</code></pre>
				<pre><code class="language-ts">observable.subscribe(observer);
					//Subscription = connects them
				</code></pre>
			</section>

			<section>
				<section>
					<h2>Operators</h2>
					<p>We use the pipe() method to apply operators to the data stream.</p>
					<ul>
						<li><strong>Change data</strong> - map, scan, and buffer.</li>
						<li><strong>Filter data</strong> - filter, take, skip, and distinct.</li>
						<li><strong>Handle errors</strong> - catchError, retry, and onErrorResumeNext.</li>
						<li><strong>For conditions</strong> - skipUntil, skipWhile, takeUntil, and takeWhile.</li>
						<li><strong>Math operations</strong> - min, max, and count.</li>
					</ul>
				</section>
				<section>
					<h3>map</h3>
					<p>Allows you to modify incoming messages and send them on.</p>
					<pre><code class="language-ts">import { from, map } from 'rxjs';

							const obs = from([1,2,3]).pipe(map(n => n * 2));
							obs.subscribe(value => console.log(value));

							// 2 4 6</code></pre>
				</section>
				<section>
					<h3>filter</h3>
					<p>Skips those values that satisfy the conditional function.</p>
					<pre><code class="language-ts">import { from, filter } from 'rxjs';

							const obs = from([1,2,3]).pipe(filter(n => n > 2));
							obs.subscribe(value => console.log(value));
							
							// 3
							</code></pre>

				</section>

				<section>
					<h3>take</h3>
					<p>take(N)it will take a maximum of N values from the source and terminate.</p>
					<pre><code class="language-ts">
							import { interval } from 'rxjs';
							import { take } from 'rxjs/operators';

							interval(1000)
							.pipe(take(3))
							.subscribe(value => console.log(value));
							
							// Console output: 0 1 2
							</code></pre>
				</section>
				<section>
					<h3>takeWhile</h3>
					<p>takeWhile(predicate) it will take values as long as the condition is true.</p>
					<pre><code class="language-ts">
						import { interval } from "rxjs";
						import { takeWhile } from "rxjs/operators";
						interval(100).pipe(
						  takeWhile(n => n < 5)
						)
						.subscribe(console.log);
						// 0, 1, 2, 3, 4
							</code></pre>
				</section>

				<section>
					<h3>reduce and scan</h3>
					<pre>
							<code class="language-ts">
				import { from } from 'rxjs';
				import { reduce } from 'rxjs/operators';
			
				const donations = from([10, 20, 30]);

							</code>
							<code class="language-ts">
				donations
					.pipe(reduce((acc, value) => acc + value, 0))
					.subscribe(total => console.log(`${total}`));
					// Console output: 60

				donations
					.pipe(scan((acc, value) => acc + value, 0))
					.subscribe(currentSum => console.log(`${currentSum}`));
				//Console output: 10 30 60
							</code>

						</pre>

				</section>

				<section>
					<h3>delay</h3>
					<p>The delay(N) operator causes a delay in the transmission of messages of N milliseconds and passes
						them on.</p>
					<pre><code class="language-ts">
						import { interval } from "rxjs";
						import { takeWhile } from "rxjs/operators";
						interval(100).pipe(
						  takeWhile(n => n < 5)
						)
						.subscribe(console.log);
						// 0, 1, 2, 3, 4
							</code></pre>
				</section>

			</section>
			<section>
				<section>
					<h2>Real-world use case</h2>
					<pre><code class="language-ts">this.searchControl.valueChanges
					.pipe(
					debounceTime(300),
					switchMap(query => this.http.get('/api?query=' + query))
					 )
					.subscribe(result => this.data = result);</code></pre>
					<p><em>Connect input to API call. Reactive and clean!</em></p>
				</section>

				<section>
					<h2>Error handling and retry</h2>
					<pre><code class="language-ts">this.http.get('/api/data')
					  .pipe(
						retry(2),
						catchError(err => of([]))
					  )
					  .subscribe(data => this.items = data);</code></pre>
					<p>Retry an observable sequence a specific number of times should an error occur.</p>
				</section>
			</section>
			<section>
				<pre>Installation<code class="language-ts">npm i rxjs</code></pre>
				<p>Interesting links</p>
				<ul>
					<li>
						<a href="https://rxviz.com/">https://rxviz.com/</a>
					</li>
					<li>
						<a href="https://rxjs.dev/guide/overview">RxJS - Introductionlink</a>
					</li>
				</ul>
			</section>

		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});
	</script>
</body>

</html>